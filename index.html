<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mappa Concettuale Multilivello</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        #graph-container {
            width: 100%;
            height: 100vh;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="graph-container">
        <svg width="800" height="600">
            <g id="graph"></g>
        </svg>
    </div>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@hpcc-js/wasm@1.20.0/dist/index.min.js"></script>
    <script src="https://unpkg.com/d3-graphviz@5.0.2/build/d3-graphviz.js"></script>
    <script>
        // Dimensioni del grafo
        const width = 800;
        const height = 600;

        // Crea un elemento SVG
        const svg = d3.select("#graph-container")
          .select("svg")
          .attr("width", width)
          .attr("height", height);

        // Crea un gruppo per contenere il grafo
        const g = svg.select("#graph");

        // Crea un div per il tooltip
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // Definisci il comportamento di zoom
        const zoom = d3.zoom()
          .scaleExtent([0.1, 4])
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
          });

        // Applica lo zoom all'SVG
        svg.call(zoom);

        function calculateDegrees(nodes, links) {
          const degreeCount = {};
          nodes.forEach(node => {
            degreeCount[node.id] = { indegree: 0, outdegree: 0 };
          });

          links.forEach(link => {
            degreeCount[link.target.id || link.target].indegree++;
            degreeCount[link.source.id || link.source].outdegree++;
          });

          nodes.forEach(node => {
            node.indegree = degreeCount[node.id].indegree;
            node.outdegree = degreeCount[node.id].outdegree;
          });
        }

        async function calculateBetweenness(nodes, links) {
          const graph = new d3.graphviz.graphlib.Graph();
          nodes.forEach(node => graph.setNode(node.id));
          links.forEach(link => graph.setEdge(link.source.id || link.source, link.target.id || link.target));

          const betweenness = await d3.graphviz.betweennessCentrality(graph);
          
          nodes.forEach(node => {
            node.betweenness = betweenness[node.id] || 0;
          });
        }

        function calculatePageRank(nodes, links, iterations = 10, dampingFactor = 0.85) {
          const N = nodes.length;
          let pageRank = {};
          
          // Inizializza PageRank
          nodes.forEach(node => {
            pageRank[node.id] = 1 / N;
          });

          for (let i = 0; i < iterations; i++) {
            let newPageRank = {};
            nodes.forEach(node => {
              newPageRank[node.id] = (1 - dampingFactor) / N;
            });

            links.forEach(link => {
              const source = link.source.id || link.source;
              const target = link.target.id || link.target;
              const sourceDegree = nodes.find(n => n.id === source).outdegree;
              newPageRank[target] += dampingFactor * pageRank[source] / sourceDegree;
            });

            pageRank = newPageRank;
          }

          nodes.forEach(node => {
            node.pageRank = pageRank[node.id];
          });
        }

        // Carica i dati dal file JSON
        d3.json("data.json").then(async data => {
          // Calcola indegree e outdegree
          calculateDegrees(data.nodes, data.links);

          // Calcola betweenness centrality
          await calculateBetweenness(data.nodes, data.links);

          // Calcola PageRank
          calculatePageRank(data.nodes, data.links);

          // Crea la simulazione di forze
          const simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).id(d => d.id))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("y", d3.forceY().strength(0.1).y(d => (d.level - 1) * height / 3));

          // Crea i link
          const link = g.append("g")
            .selectAll("line")
            .data(data.links)
            .enter().append("line")
            .attr("stroke", "#999")
            .attr("stroke-opacity", 0.6);

          // Crea i nodi
          const node = g.append("g")
            .selectAll("circle")
            .data(data.nodes)
            .enter().append("circle")
            .attr("r", 5)
            .attr("fill", d => d3.schemeCategory10[d.level])
            .call(d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended))
            .on("mouseover", (event, d) => {
              tooltip.transition()
                .duration(200)
                .style("opacity", .9);
              tooltip.html(`Nome: ${d.name}<br/>
                            Livello: ${d.level}<br/>
                            Indegree: ${d.indegree}<br/>
                            Outdegree: ${d.outdegree}<br/>
                            Betweenness: ${d.betweenness.toFixed(4)}<br/>
                            PageRank: ${d.pageRank.toFixed(4)}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", (d) => {
              tooltip.transition()
                .duration(500)
                .style("opacity", 0);
            });

          // Aggiungi etichette ai nodi
          const label = g.append("g")
            .selectAll("text")
            .data(data.nodes)
            .enter().append("text")
            .text(d => d.name)
            .attr("font-size", 10)
            .attr("dx", 12)
            .attr("dy", 4);

          // Aggiorna le posizioni durante la simulazione
          simulation.on("tick", () => {
            link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);

            node
              .attr("cx", d => d.x)
              .attr("cy", d => d.y);

            label
              .attr("x", d => d.x)
              .attr("y", d => d.y);
          });

          // Funzioni per il drag dei nodi
          function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
          }

          function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }
        });
    </script>
</body>
</html>